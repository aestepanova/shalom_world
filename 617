program lab_6_17;
   {$APPTYPE CONSOLE}
   {$R *.res}
uses
  System.SysUtils, Windows;

type PWords = ^words;   { указатель на слово }
     words = record    { структура узла }
       word: string[40]; { слово }
       next: PWords;      { ссылка на следующее слово }
     end;

type ff = textfile;
     ss = string[40];

var f: ff;
var s, w, kolvo: ss;
var num, i, n: integer;
var Head, p: PWords;
var sogl: string[4];
type arr = array [2..10] of PWords;
var a:arr;

//занесение информации в файл
procedure NewInfo(var f:ff);
begin
    rewrite(f);
    for i:=1 to n do
    begin
      writeln('Enter word: ');
      readln(w);
      writeln(f,w);
    end;
     close(f);
end;

procedure ReadF(var f:ff);
var k: PWords;
begin
    reset(f);
    while (not eof(f)) do
      begin
       Readln(f,s);
       if length(s)=1 then
        begin
        writeln('Зачем вам буква, Лебовски?');
        break;
        end;
       if length(s)>10 then
        begin
        writeln('Вы превысили допустимое количество символов');
        break;
        end;
       p:=a[(length(s))];
       while p^.next<>nil do
        begin
           p:=p^.next
        end;
        if p <> nil then
          begin
            new(k);
            k^.next:=p^.next;
            p^.next:=k;
            k^.word:=s;
          end;
      end;
     close(f);
end;

procedure output(var head: PWords; kolvo:ss);
begin
  p:=head;
  write(kolvo);
  while p <> nil do
  begin
    write(p^.word + ' ');
    p:=p^.next;
  end;
end;

procedure SortBublInf(head:PWords);
var
  tmp,rab:PWords;
  slovo: ss;
begin
  new(tmp); {выделяем память для рабочего "буфера" обмена}
  rab:=head; {рабочая ссылка, становимся на вершину стека}
  while rab<>nil do {пока мы не дойдём до конца стека делать}
  begin
    tmp:=rab^.next; {перейдём на следующий элемент}
    while tmp<>nil do {пока не конец стека делать}
    begin
      if tmp^.word < rab^.word then {проверяем следует ли менять элементы}
      begin
        slovo:=tmp^.word;
        tmp^.word:=rab^.word;
        rab^.word:=slovo;
      end;
      tmp:=tmp^.next {переход к следующему элементу}
    end;
    rab:=rab^.next {переход к следующему элементу}
  end
end;

procedure deleteX(var head:PWords);
var tmp: PWords;
begin
  p:=head;
  while (p^.next <> nil) and ( p^.next^.word <> p^.word) do
  begin
    p:=p^.next;
  end;
  if p^.next <> nil then
    begin
    tmp:=p^.next;
    p^.next:=p^.next^.next;
    dispose(tmp);
    end;
end;

{Освобождение памяти, занятой для элементов списка и инициализация.}
procedure ListFree(var head : PWords);
var
 P, PDel : PWords;
begin
 P := head^.next; {Указатель на первый элемент списка.}
 while P <> nil do
 begin
  PDel := P;   {Запоминаем указатель на текущий элемент.}
  P := P^.next; {Получаем указатель на следующий элемент.}
  Dispose(PDel); {Освобождаем память, занятую текущим элементом списка.}
 end;
end;

begin
  writeln('Enter number of words: ');
  readln(n);
  new(p);
  p^.next:=nil;
  for i := 2 to 10 do
    begin
      new(a[i]);
      a[i]^.next:=nil;
    end;

    assign(f,'C:\labs\AEStepanova_labs\go.pri');
    NewInfo(f);
    ReadF(f);

    writeln('Список с каким количеством букв вывести(от 2 до 10): ');
    readln (NUM);
    case NUM of
      2:write ('Two letters: ');
      3:write ('Three letters: ');
      4:write ('Four letters: ');
      5:write ('Five letters: ');
      6:write ('Six letters: ');
      7:write ('Seven letters: ');
      8:write ('Eight letters: ');
      9:write ('Nine letters: ');
      10:write ('Ten letters: ');
    end;
    head:=a[num];
    Output(head, kolvo);
    writeln('');

    writeln('Удалить из каждого списка повторяющиеся слова(Yes/No): ');
    readln(sogl);
    if sogl='Yes' then
    begin
      for i := 2 to 10 do
        begin
          kolvo:=inttostr(i)+ ': ';
          head:=a[i];
          SortBublInf(head);
          deleteX(head);
          Output(head, kolvo);
        end;
    end;

    for i := 2 to 10 do
      begin
        head:=a[i];
        ListFree(head);
      end;

    readln;
end.
